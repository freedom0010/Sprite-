// éšæœºå»¶è¿Ÿå‡½æ•°ï¼Œæ¨¡æ‹Ÿäººç±»æ“ä½œçš„è‡ªç„¶é—´éš”
function randomDelay(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

// æ”¹è¿›çš„ sleep å‡½æ•°
function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// æ¨¡æ‹Ÿé¼ æ ‡ç§»åŠ¨è½¨è¿¹
async function simulateMouseMove(element) {
    if (!element) return;
    const rect = element.getBoundingClientRect();
    const startX = Math.random() * window.innerWidth;
    const startY = Math.random() * window.innerHeight;
    const endX = rect.left + rect.width / 2 + (Math.random() * 20 - 10); // è½»å¾®åç§»
    const endY = rect.top + rect.height / 2 + (Math.random() * 20 - 10);

    const steps = 10 + Math.floor(Math.random() * 15); // éšæœºæ­¥æ•°
    for (let i = 0; i <= steps; i++) {
        const x = startX + (endX - startX) * (i / steps);
        const y = startY + (endY - startY) * (i / steps);
        window.dispatchEvent(new MouseEvent('mousemove', { clientX: x, clientY: y, bubbles: true }));
        await sleep(randomDelay(10, 30));
    }
}

// æ¨¡æ‹Ÿéšæœºé¼ æ ‡æ™ƒåŠ¨ï¼ˆæ— ç›®æ ‡ï¼‰
async function simulateRandomMouseWiggle() {
    const x = Math.random() * window.innerWidth;
    const y = Math.random() * window.innerHeight;
    window.dispatchEvent(new MouseEvent('mousemove', { clientX: x, clientY: y, bubbles: true }));
    await sleep(randomDelay(200, 500));
}

// æ¨¡æ‹Ÿé¡µé¢æ»šåŠ¨
async function simulateScroll() {
    const scrollDistance = Math.random() * 200 - 100; // éšæœºä¸Šä¸‹æ»šåŠ¨
    window.scrollBy(0, scrollDistance);
    await sleep(randomDelay(300, 800));
}

// æ¨¡æ‹Ÿå¤±ç„¦è¡Œä¸º
async function simulateLoseFocus() {
    if (Math.random() < 0.1) { // 10% æ¦‚ç‡å¤±ç„¦
        console.log("ğŸ˜´ æ¨¡æ‹Ÿå¤±ç„¦");
        document.activeElement?.blur();
        await sleep(randomDelay(500, 2000));
        // é‡æ–°èšç„¦è¾“å…¥æ¡†
        const input = document.querySelector('input[type="text"]');
        if (input) {
            input.focus();
            await sleep(randomDelay(200, 500));
        }
    }
}

// æ¨¡æ‹Ÿäººç±»è¾“å…¥ï¼ˆ60% è¯†åˆ«å‡†ç¡®ç‡ï¼Œ80% æ›´æ­£ç‡ï¼‰
async function triggerInput(input, value) {
    const nativeInputValueSetter = Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype, 'value').set;
    const inputEvent = new Event('input', { bubbles: true });

    let currentValue = input.value || '';
    for (let i = 0; i < value.length; i++) {
        const correctChar = value[i];
        let charToType = correctChar;

        // 40% æ¦‚ç‡è¾“å…¥é”™è¯¯å­—ç¬¦
        if (Math.random() < 0.4) {
            const wrongChar = String.fromCharCode(97 + Math.floor(Math.random() * 26)); // éšæœºå°å†™å­—æ¯
            charToType = wrongChar;
            currentValue += charToType;
            nativeInputValueSetter.call(input, currentValue);
            input.dispatchEvent(new KeyboardEvent('keydown', { key: charToType, bubbles: true }));
            input.dispatchEvent(inputEvent);
            input.dispatchEvent(new KeyboardEvent('keyup', { key: charToType, bubbles: true }));
            await sleep(randomDelay(50, 150));

            // 80% æ¦‚ç‡æ›´æ­£é”™è¯¯
            if (Math.random() < 0.8) {
                currentValue = currentValue.slice(0, -1); // åˆ é™¤é”™è¯¯å­—ç¬¦
                nativeInputValueSetter.call(input, currentValue);
                input.dispatchEvent(new KeyboardEvent('keydown', { key: 'Backspace', bubbles: true }));
                input.dispatchEvent(inputEvent);
                input.dispatchEvent(new KeyboardEvent('keyup', { key: 'Backspace', bubbles: true }));
                await sleep(randomDelay(100, 300));
                charToType = correctChar; // è¾“å…¥æ­£ç¡®å­—ç¬¦
            } else {
                continue; // ä¸æ›´æ­£ï¼Œä¿ç•™é”™è¯¯
            }
        }

        // è¾“å…¥æ­£ç¡®æˆ–æ›´æ­£åçš„å­—ç¬¦
        currentValue += charToType;
        nativeInputValueSetter.call(input, currentValue);
        input.dispatchEvent(new KeyboardEvent('keydown', { key: charToType, bubbles: true }));
        input.dispatchEvent(inputEvent);
        input.dispatchEvent(new KeyboardEvent('keyup', { key: charToType, bubbles: true }));
        await sleep(randomDelay(50, 150)); // è‡ªç„¶æŒ‰é”®é—´éš”
    }
}

// æ”¹è¿›çš„ç‚¹å‡»å‡½æ•°
async function clickElement(element) {
    if (element && !element.disabled) {
        try {
            await simulateMouseMove(element); // æ¨¡æ‹Ÿé¼ æ ‡ç§»åŠ¨
            element.dispatchEvent(new MouseEvent('mouseover', { bubbles: true, cancelable: true, view: window }));
            await sleep(randomDelay(20, 50));
            element.dispatchEvent(new MouseEvent('mousedown', { bubbles: true, cancelable: true, view: window }));
            await sleep(randomDelay(20, 50));
            element.dispatchEvent(new MouseEvent('mouseup', { bubbles: true, cancelable: true, view: window }));
            element.dispatchEvent(new MouseEvent('click', { bubbles: true, cancelable: true, view: window }));
            console.log(`âœ… ç‚¹å‡»å…ƒç´ : ${element.textContent.trim().substring(0, 20)}`);
            return true;
        } catch (e) {
            console.log(`âŒ ç‚¹å‡»å¤±è´¥: ${e.message}`);
            return false;
        }
    }
    return false;
}

// æ¨¡æ‹Ÿ Tab é”®
async function triggerSingleTab() {
    const el = document.activeElement;
    if (el) {
        el.dispatchEvent(new KeyboardEvent('keydown', { key: 'Tab', code: 'Tab', keyCode: 9, which: 9, bubbles: true }));
        await sleep(randomDelay(20, 50));
        el.dispatchEvent(new KeyboardEvent('keyup', { key: 'Tab', code: 'Tab', keyCode: 9, which: 9, bubbles: true }));
    }
}

// æŸ¥æ‰¾æŒ‰é’®
function findButton(text) {
    const buttons = document.querySelectorAll('button');
    return Array.from(buttons).find(btn => btn.textContent.includes(text));
}

// ç­‰å¾…è¾“å…¥æ¡†èšç„¦å’Œæ–°å•è¯
async function waitForInputFocusAndNewWord(maxAttempts = 10) {
    let attempts = 0;
    while (attempts < maxAttempts) {
        const input = document.querySelector('input[type="text"]');
        const wordElems = document.querySelectorAll('div[class*="text-"]');
        const activeWord = Array.from(wordElems).find(el =>
            el.innerText.trim().length > 0 &&
            window.getComputedStyle(el).color === 'rgb(255, 255, 255)'
        );

        if (input && document.activeElement === input && activeWord) {
            return true;
        }
        await triggerSingleTab();
        await sleep(randomDelay(300, 700));
        attempts++;
    }
    return false;
}

// æ¨¡æ‹ŸåŒ Tab
async function triggerDoubleTab() {
    console.log("ğŸ”„ğŸ”„ æ¨¡æ‹ŸåŒ Tab é”®");
    await triggerSingleTab();
    await sleep(randomDelay(80, 150));
    await triggerSingleTab();
}

// ä¸»å¾ªç¯
async function main() {
    let loopCount = 0;
    const maxLoops = 100; // é™åˆ¶æœ€å¤§å¾ªç¯æ¬¡æ•°

    while (loopCount < maxLoops) {
        loopCount++;
        // éšæœºæš‚åœï¼Œæ¨¡æ‹Ÿäººç±»ä¼‘æ¯ï¼ˆ15% æ¦‚ç‡ï¼‰
        if (Math.random() < 0.15) {
            console.log("ğŸ˜´ æ¨¡æ‹Ÿäººç±»ä¼‘æ¯");
            await sleep(randomDelay(1000, 5000));
        }

        // æ¨¡æ‹Ÿéšæœºé¼ æ ‡æ™ƒåŠ¨ï¼ˆ20% æ¦‚ç‡ï¼‰
        if (Math.random() < 0.2) {
            await simulateRandomMouseWiggle();
        }

        // æ¨¡æ‹Ÿé¡µé¢æ»šåŠ¨ï¼ˆ20% æ¦‚ç‡ï¼‰
        if (Math.random() < 0.2) {
            await simulateScroll();
        }

        // æ¨¡æ‹Ÿå¤±ç„¦ï¼ˆ10% æ¦‚ç‡ï¼‰
        await simulateLoseFocus();

        const input = document.querySelector('input[type="text"]');
        if (!input) {
            await sleep(randomDelay(800, 1500));
            continue;
        }

        input.focus();
        await clickElement(input);

        const submitButton = findButton('Submit to Leaderboard');
        if (submitButton) {
            await sleep(randomDelay(500, 1000)); // æ¨¡æ‹Ÿäººç±»æ€è€ƒ
            while (!await clickElement(submitButton)) await sleep(randomDelay(300, 600));
            await sleep(randomDelay(1500, 3000));

            const playAgainButton = findButton('Play Again');
            if (playAgainButton) {
                await sleep(randomDelay(500, 1000));
                while (!await clickElement(playAgainButton)) await sleep(randomDelay(300, 600));
                await sleep(randomDelay(2000, 4000));
                await waitForInputFocusAndNewWord();
                await triggerSingleTab();
                continue;
            }
        }

        const wordElems = document.querySelectorAll('div[class*="text-"]');
        const activeWord = Array.from(wordElems).find(el =>
            el.innerText.trim().length > 0 &&
            window.getComputedStyle(el).color === 'rgb(255, 255, 255)'
        );

        if (!activeWord) {
            await sleep(randomDelay(800, 1500));
            continue;
        }

        const word = activeWord.innerText.trim();
        console.log(`ğŸ“ æ­£åœ¨è¾“å…¥: ${word}`);
        await triggerInput(input, word + ' ');
        await sleep(randomDelay(150, 300));

        if (wordElems.length === 1) {
            await triggerDoubleTab();
            await sleep(randomDelay(800, 1200));

            const playAgainButton = findButton('Play Again');
            if (playAgainButton) {
                console.log("ğŸ”„ åŒ Tab å¯èƒ½å¤±è´¥ï¼Œå°è¯•ç‚¹å‡» Play Again æŒ‰é’®");
                await sleep(randomDelay(500, 1000));
                while (!await clickElement(playAgainButton)) await sleep(randomDelay(300, 600));
                await sleep(randomDelay(2000, 4000));
                await waitForInputFocusAndNewWord();
                await triggerSingleTab();
            }
        }

        await sleep(randomDelay(300, 800));
    }
    console.log("ğŸ”š è¾¾åˆ°æœ€å¤§å¾ªç¯æ¬¡æ•°ï¼Œè„šæœ¬åœæ­¢");
}

// è¿è¡Œä¸»å‡½æ•°
main().catch(err => console.error("âŒ è„šæœ¬é”™è¯¯:", err));
